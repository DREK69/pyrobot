import random
import re
import string
from math import ceil
from random import sample
from typing import Dict, List

import httpx
from somnium import Somnium as som
from somnium.sync import Somnium

from pyrogram import enums, filters
from pyrogram.types import *

from MerissaRobot import pbot
from MerissaRobot.helpers import getreq


class Lexica:
    def __init__(
        self,
        query,
        negativePrompt="",
        guidanceScale: int = 7,
        portrait: bool = True,
        cookie=None,
    ):
        self.query = query
        self.negativePrompt = negativePrompt
        self.guidanceScale = guidanceScale
        self.portrait = portrait
        self.cookie = cookie

    def images(self):
        response = httpx.post(
            "https://lexica.art/api/infinite-prompts",
            json={
                "text": self.query,
                "searchMode": "images",
                "source": "search",
                "model": "lexica-aperture-v2",
            },
        )

        prompts = [
            f"https://image.lexica.art/full_jpg/{ids['id']}"
            for ids in response.json()["images"]
        ]

        return prompts

    def _generate_random_string(self, length):
        chars = string.ascii_letters + string.digits
        result_str = "".join(random.choice(chars) for _ in range(length))

        return result_str


@pbot.on_message(filters.command(["gpt", "ask", "chatgpt"]))
async def chatgpt(c, message):
    if len(message.command) == 1:
        return await message.reply_msg(
            "Give me some questions to ask Chatgpt AI. Example- /ask question"
        )
    query = message.text.split(None, 1)[1]
    msg = await message.reply_text(
        "Wait a moment looking for your answer..", quote=True
    )
    try:
        await c.send_chat_action(message.chat.id, enums.ChatAction.TYPING)
        x = await getreq(f"https://vihangayt.me/tools/chatgpt?q={query}")
        response = x["data"]
    except:
        response = "Something Went Wrong"
    await msg.edit_text(response)
    await c.send_chat_action(message.chat.id, enums.ChatAction.CANCEL)


@pbot.on_message(filters.command(["bard", "googleai"]))
async def bard_chatbot(c, message):
    if len(message.command) == 1:
        return await message.reply_text(
            "Give me some questions to ask Bard AI. Example- /bard question"
        )
    query = message.text.split(None, 1)[1]
    msg = await message.reply_text(
        "Wait a moment looking for your answer..", quote=True
    )
    try:
        await c.send_chat_action(message.chat.id, enums.ChatAction.TYPING)
        x = await getreq(f"https://vihangayt.me/tools/bard?q={query}")
        response = x["data"]
    except:
        response = "Something went wrong"
    await msg.edit_text(response)
    await c.send_chat_action(message.chat.id, enums.ChatAction.CANCEL)


@pbot.on_message(filters.command("lexica"))
async def ai_img_search(c, m):
    try:
        prompt = m.text.split(None, 1)[1]
    except IndexError:
        await m.reply_text(
            "`What should i imagine??\nGive some prompt along with the command`"
        )
        return
    x = await m.reply_text("`Processing...`")
    try:
        lex = Lexica(query=prompt).images()
        k = sample(lex, 4)
        result = [InputMediaPhoto(image) for image in k]
        await c.send_media_group(
            chat_id=m.chat.id,
            media=result,
            reply_to_message_id=m.id,
        )
        await x.delete()
    except:
        await x.edit("`Failed to get images`")


styles = som.Styles()
revstyle = {str(v): k for k, v in styles.items()}
ROWS = 6
COLS = 2


@pbot.on_message(filters.command("dream"))
async def somni(bot, m):
    try:
        dream = m.text.split(" ", 1)[1]
    except:
        return await m.reply("Give some text to generate image.")
    await m.reply_text(
        f"**Dream = **{dream}",
        reply_markup=InlineKeyboardMarkup(paginate_styles(0, ROWS, COLS, styles)),
        quote=True,
    )


@pbot.on_callback_query(filters.regex("^somnium"))
async def somni_callback(bot, query):
    dream = query.message.text.split("= ")[1]
    style_match = re.match(r"somnium_style_(.*)", query.data)
    prev_match = re.match(r"somnium_prev\((.*)\)", query.data)
    next_match = re.match(r"somnium_next\((.*)\)", query.data)
    try:
        if style_match:
            style = style_match.group(1)
            stylename = revstyle[str(style)]
            m = await query.message.edit_text(
                f"Processing the image with style {stylename}... Have Patience.."
            )
            try:
                img = await Somnium.Generate(dream, style)
                await query.message.reply_document(
                    img,
                    caption=f"**Prompt:** {dream}\n**Style:** {stylename}\n\nGenerated By @MerissaRobot",
                )
            except:
                await query.message.edit_text(
                    f"I am Unable to Create dream: {dream} on this style: {stylename}\nPlease try again"
                )
            await m.delete()

        elif prev_match:
            curr_page = int(prev_match.group(1))
            await query.message.edit_reply_markup(
                InlineKeyboardMarkup(paginate_styles(curr_page - 1, ROWS, COLS, styles))
            )

        elif next_match:
            curr_page = int(next_match.group(1))
            await query.message.edit_reply_markup(
                InlineKeyboardMarkup(paginate_styles(curr_page + 1, ROWS, COLS, styles))
            )
        await query.answer()

    except Exception:
        pass


def paginate_styles(page_n: int, rows: int, cols: int, style_dict: Dict) -> List:
    styles = [
        InlineKeyboardButton(k, callback_data=f"somnium_style_{v}")
        for k, v in style_dict.items()
    ]
    pairs = [
        styles[i * cols : (i + 1) * cols]
        for i in range((len(styles) + cols - 1) // cols)
    ]
    num_of_pages = ceil(len(styles) / (rows * cols))
    modulo_page = page_n % num_of_pages
    pairs = pairs[modulo_page * rows : (modulo_page + 1) * rows] + [
        (
            InlineKeyboardButton("⇚", callback_data=f"somnium_prev({modulo_page})"),
            InlineKeyboardButton("⇛", callback_data=f"somnium_next({modulo_page})"),
        )
    ]
    return pairs
